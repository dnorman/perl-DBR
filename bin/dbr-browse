#!/usr/bin/perl -w

#  dbr-browse
#
#  % pod2text ./dbr-browse

use strict;
use warnings;

use Data::Dumper;

use DBR;
use DBR::Util::Logger;

my $conf = shift @ARGV or die "\nusage: $0 <path to DBR conf file> [ <class> ]\n\n";
my $class = shift @ARGV || 'query';

my $logger = new DBR::Util::Logger(-logpath => '/tmp/dbr_browse.log', -logLevel => 'warn') or die "no logger!\n";
my $dbr    = new DBR( -logger => $logger, -conf => $conf ) or die "\nno dbr - check config file path\n\n";

my $lookup = {};
my @tables = ();  # persistent filtered results

while (1) {
      my $schema_handle = &get_schema or last;
      my $inst  = $dbr->get_instance( $schema_handle, $class ) or die "failed to get instance!\n";
      my $info = $inst->schema->browse or die "\nfailed to get browse info!\n\n";
      #print "INFO:\n", Dumper( $info );
      &browse( $info );
}

sub browse {
      my $info = shift or die "no info!\n";

      print "\nBrowsing " . $info->{schema}->{display} . "\n\n";

      # build lookups
      $lookup->{table} = { map { $_->{name} => $_ } @{ $info->{schema}->{tables} } };

      while (1) {
            my $trec = &get_table( $info ) or last;
            my @fields = ();
            foreach my $frec (@{$trec->{fields}}) {
                  my $field = {
                               field  => $frec->{name},
                               type   => $frec->{type},
                               trans  => $frec->{trans},
                               target => $frec->{to},
                               via    => $frec->{via},
                               enums  => $frec->{enums} ? join( ', ', @{ $frec->{enums} } ) : '',
                              };
                  $frec->{pkey} ?
                    unshift @fields, $field :
                      push @fields, $field;
            }
            print "\n$trec->{name}:\n";
            &grid( \@fields, qw( field type trans target via enums ) );

            if ($trec->{from}) {
                  print "Targeted By:\n";
                  &grid( $trec->{from}, qw( path via ) );
            }
      }
}

sub get_table {
      my $info = shift;

      my $table;

      while (1) {
            print "\nTABLE> ";  chomp( $table = <STDIN> );
            last unless length( $table );

            # numeric pick from previous filter
            if ($table =~ m!^\d+$! && $table < @tables) {
                  $table = $tables[$table];
                  last;
            }

            # search for matching table names
            @tables = 
              map { $_->{name} }
                grep { $table eq '?' || $_->{name} =~ m!$table! }
                  @{ $info->{schema}->{tables} };

            # exact match
            $table = $tables[0] and last if @tables == 1;

            print "no matches!\n" and next unless @tables;

            # list matches
            my $idx = 0;
            foreach my $tname (@tables) {
                  printf "  %3d) %s\n", $idx++, $tname;
            }
      }

      return $table ? $lookup->{table}->{$table} : undef;
}

sub get_schema {
      print "\nAvailable Schemas:\n   ";
      print join( "\n   ", map { $_->{handle} } @{ DBR::Config::Schema->list_schemas } );
      print "\n\nSCHEMA> "; chomp( my $handle = <STDIN> );
      return $handle;
}

sub grid {
      my $rows = shift;  # data rows
      my @fields = @_;   # column keys order
      my %max = ();
      foreach my $row ({ map { $_ => $_ } @fields }, @{$rows}) {
            foreach my $field (@fields) {
                  my $len = defined $row->{$field} ? length( $row->{$field} ) : 0;
                  $max{$field} = $len if $len && $len > ($max{$field}||=0);
            }
      }
      my $box = '+-' . join( '-+-', map { '-' x $max{$_} } @fields ) . '-+';
      print "$box\n";
      print '| ' . join( ' | ', map { sprintf( '%'.$max{$_}.'s', $_ ) } @fields ) . " |\n";
      print "$box\n";
      foreach my $row (@{$rows}) {
            my @vals = ();
            foreach my $field (@fields) {
                  my $val = $row->{$field};
                  my $just = $max{$field} > 20 ? '-' : '';  # cheap justification heuristic
                  push @vals, sprintf( '%'.$just.$max{$field}.'s', defined $val ? $val : '' );
            }
            print '| ' . join( ' | ', @vals ) . " |\n";
      }
      print "$box\n";
}

1;

=pod

=head1 Title

Simple DBR Schema Browser

=head1 Synopsis

    % dbr-browse dbr.conf

    % dbr-browse foo.conf master

If you have not installed DBR yet:

    % perl -I ../lib dbr-browse bar.conf

=head1 Description

dbr-browse is a DBR tool that shows you database tables with DBR metadata mixed in.
DBR metadata includes the translator type (e.g. UnixTime, Dollars, Enum, Percent),
enumeration handles associated with an Enum field, and the forward and backward
names of relationships to other tables via foreign keys.

At present, the dbr-admin tool is the preferred method for adding in DBR metadata.
Developers will subsequently find dbr-browse a useful tool for coding the correct
names in "table paths" when accessing data from a Record object, specifying key
values to use with ResultSet's hasmap_single() and hashmap_multi() methods, and
when expressing constraints for an Object where() method.

=head1 Use

    The config file parameter establishes your access to a collection of databases.

    Those databases that have been scanned will have schema data available.

    The schemas will be listed and you will be prompted to enter the name of one.

    Table view mode is now entered.

    Your remaining inputs will be the name (or number) of a table to view.

    A blank input will return to the schema prompt; blank input again will exit.

    A '?' will list all tables, otherwise a list will be shown matching the input.

    When presented with a list, enter the number for the item or key in the full name.

    The number must be used if the table name is also a substring of other table names.

=head1 Examples

    examples/music/browse_test.sh

=cut
